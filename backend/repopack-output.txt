This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-05-05T22:52:03.358Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
app/
  core/
    config.py
    database.py
    security.py
  models/
    transaction.py
    user.py
  routes/
    analytics.py
    auth.py
    transactions.py
  schemas/
    transaction.py
    user.py
  test/
    auth-test.py
  utils/
    environment.py
  main.py
.gitignore
Dockerfile
requirements.txt

================================================================
Repository Files
================================================================

================
File: app/core/config.py
================
import os
from typing import List, Optional
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    # Project info
    PROJECT_NAME: str
    PROJECT_VERSION: str
    PROJECT_DESCRIPTION: str
    
    # Database
    DATABASE_URL: str
    
    # CORS
    CORS_ORIGINS: List[str] = ["*"]
    
    # JWT
    JWT_SECRET_KEY: str
    JWT_ALGORITHM: str
    JWT_ACCESS_TOKEN_EXPIRE_MINUTES: int
    
    # Password hashing
    PWD_CONTEXT_SCHEMES: List[str] = ["bcrypt"]
    PWD_CONTEXT_DEPRECATED: str = "auto"
    
    # Environment
    ENV: Optional[str] = os.getenv("ENV", "development")
    
    # SSL Settings for Neon Postgres
    SSL_MODE: Optional[str] = os.getenv("SSL_MODE", "require")
    
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=True
    )
    
    @property
    def database_url_with_ssl(self) -> str:
        """
        If using Neon Postgres, ensure SSL is properly configured
        """
        if "neon.tech" in self.DATABASE_URL and "sslmode=" not in self.DATABASE_URL:
            if "?" in self.DATABASE_URL:
                return f"{self.DATABASE_URL}&sslmode={self.SSL_MODE}"
            else:
                return f"{self.DATABASE_URL}?sslmode={self.SSL_MODE}"
        return self.DATABASE_URL
    
    def get_db_url(self) -> str:
        """
        Return the database URL with SSL configuration if necessary
        """
        return self.database_url_with_ssl

settings = Settings()

================
File: app/core/database.py
================
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

from app.core.config import settings

SQLALCHEMY_DATABASE_URL = settings.get_db_url()

engine_args = {}
if "neon.tech" in SQLALCHEMY_DATABASE_URL:
    engine_args.update({
        "pool_pre_ping": True,  # Check connection before using from pool
        "pool_recycle": 300,    # Recycle connections every 5 minutes
        "pool_size": 5,         # Maintain a pool of 5 connections
        "max_overflow": 10      # Allow up to 10 overflow connections
    })

engine = create_engine(SQLALCHEMY_DATABASE_URL,**engine_args)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

================
File: app/core/security.py
================
from datetime import datetime, timedelta
from typing import Any, Optional, Union

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.orm import Session

from app.core.config import settings
from app.models.user import User
from app.core.database import SessionLocal

# Password hashing
pwd_context = CryptContext(
    schemes=settings.PWD_CONTEXT_SCHEMES,
    deprecated=settings.PWD_CONTEXT_DEPRECATED,
)

# OAuth2 scheme for tokens
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify that the plain password matches the hashed password
    """
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """
    Hash a password using the configured context
    """
    return pwd_context.hash(password)

def create_access_token(subject: Union[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    """
    Create a JWT token
    """
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=settings.JWT_ACCESS_TOKEN_EXPIRE_MINUTES
        )
    
    to_encode = {"exp": expire, "sub": str(subject)}
    encoded_jwt = jwt.encode(
        to_encode, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM
    )
    
    return encoded_jwt

def get_db():
    """
    Get a database session
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_current_user(
    db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> User:
    """
    Get the current user from the token
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(
            token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM]
        )
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise credentials_exception
    
    return user

================
File: app/models/transaction.py
================
import uuid
from sqlalchemy import Column, String, Float, Date, DateTime, ForeignKey, Text, Enum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
import enum

from app.core.database import Base

class TransactionType(str, enum.Enum):
    INCOME = "income"
    EXPENSE = "expense"

class Transaction(Base):
    __tablename__ = "transactions"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    description = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    date = Column(Date, nullable=False)
    type = Column(Enum(TransactionType), nullable=False)
    category = Column(String, nullable=False)
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="transactions")
    
    def __repr__(self):
        return f"<Transaction {self.description} - {self.amount}>"

================
File: app/models/user.py
================
import uuid
from sqlalchemy import Column, String, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship

from app.core.database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    password = Column(String, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    
    # Relationships
    transactions = relationship("Transaction", back_populates="user", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<User {self.email}>"

================
File: app/routes/analytics.py
================
from datetime import datetime, timedelta
from collections import defaultdict
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.models.transaction import Transaction
from app.schemas.transaction import TransactionAnalytics

router = APIRouter()

@router.get("", response_model=TransactionAnalytics)
def get_analytics(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    timeframe: str = "month",  # month, quarter, year
):
    """
    Get analytics for a user
    """
    # Get all transactions for the user
    transactions = (
        db.query(Transaction)
        .filter(Transaction.user_id == current_user.id)
        .all()
    )
    
    # Calculate monthly summary
    monthly_summary = calculate_monthly_summary(transactions, timeframe)
    
    # Calculate category breakdown
    category_breakdown = calculate_category_breakdown(transactions)
    
    # Calculate income vs expense
    income_vs_expense = calculate_income_vs_expense(transactions)
    
    return {
        "monthly_summary": monthly_summary,
        "category_breakdown": category_breakdown,
        "income_vs_expense": income_vs_expense,
    }

def calculate_monthly_summary(transactions, timeframe):
    """
    Calculate monthly summary
    """
    # Determine number of months to include
    months_to_include = 6
    if timeframe == "quarter":
        months_to_include = 12
    elif timeframe == "year":
        months_to_include = 24
    
    # Get date range
    end_date = datetime.now()
    start_date = end_date - timedelta(days=30 * months_to_include)
    
    # Group transactions by month
    monthly_data = defaultdict(lambda: {"income": 0, "expense": 0, "net": 0})
    
    for transaction in transactions:
        # Skip transactions outside the date range
        transaction_date = datetime.combine(transaction.date, datetime.min.time())
        if transaction_date < start_date:
            continue
        
        # Format month key
        month_key = transaction_date.strftime("%b %Y")
        
        # Add to monthly data
        if transaction.type == "income":
            monthly_data[month_key]["income"] += transaction.amount
        else:
            monthly_data[month_key]["expense"] += transaction.amount
        monthly_data[month_key]["net"] = monthly_data[month_key]["income"] - monthly_data[month_key]["expense"]
    
    # Convert to list and sort by date
    monthly_summary = []
    for month, data in monthly_data.items():
        monthly_summary.append({
            "month": month,
            **data
        })
    
    # Sort by date
    monthly_summary.sort(key=lambda x: datetime.strptime(x["month"], "%b %Y"))
    
    return monthly_summary

#Analytics Calculation
def calculate_category_breakdown(transactions):
    """
    Calculate category breakdown
    """
    # Filter expense transactions
    expense_transactions = [t for t in transactions if t.type == "expense"]
    
    # Group by category
    category_totals = defaultdict(float)
    for transaction in expense_transactions:
        category_totals[transaction.category] += transaction.amount
    
    # Calculate total expense
    total_expense = sum(category_totals.values())
    
    # Calculate percentages
    category_breakdown = []
    for category, amount in category_totals.items():
        percentage = (amount / total_expense * 100) if total_expense > 0 else 0
        category_breakdown.append({
            "name": category,
            "amount": amount,
            "percentage": round(percentage, 2),
        })
    
    # Sort by amount
    category_breakdown.sort(key=lambda x: x["amount"], reverse=True)
    
    return category_breakdown

def calculate_income_vs_expense(transactions):
    """
    Calculate income vs expense
    """
    total_income = sum(t.amount for t in transactions if t.type == "income")
    total_expense = sum(t.amount for t in transactions if t.type == "expense")
    net = total_income - total_expense
    
    return {
        "income": total_income,
        "expense": total_expense,
        "net": net,
    }

================
File: app/routes/auth.py
================
from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.core.security import (
    get_password_hash, 
    verify_password, 
    create_access_token, 
    get_current_user
)
from app.core.config import settings
from app.models.user import User
from app.schemas.user import UserCreate, UserResponse, Token, UserLogin

router = APIRouter()

@router.post("/signup", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def signup(user_in: UserCreate, db: Session = Depends(get_db)):
    """
    Create a new user
    """
    # Check if the user already exists
    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered",
        )
    
    # Create the user
    hashed_password = get_password_hash(user_in.password)
    user = User(
        email=user_in.email,
        name=user_in.name,
        password=hashed_password,
    )
    db.add(user)
    db.commit()
    db.refresh(user)
    
    return user

#Authentication Flow
@router.post("/login", response_model=Token)
def login(user_in: UserLogin, db: Session = Depends(get_db)):
    """
    OAuth2 compatible token login, get an access token for future requests
    """
    # Check if the user exists
    user = db.query(User).filter(User.email == user_in.email).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Check the password
    if not verify_password(user_in.password, user.password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Create the access token
    access_token_expires = timedelta(minutes=settings.JWT_ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        subject=str(user.id), expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer", "user": user}

@router.get("/me", response_model=UserResponse)
def get_current_user_info(current_user: User = Depends(get_current_user)):
    """
    Get current user info
    """
    return current_user

================
File: app/routes/transactions.py
================
from typing import List
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from uuid import UUID

from app.core.database import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.models.transaction import Transaction
from app.schemas.transaction import (
    TransactionCreate,
    TransactionUpdate,
    TransactionResponse,
    TransactionSummary
)

router = APIRouter()

#Transaction Processing Logic
@router.post("", response_model=TransactionResponse, status_code=status.HTTP_201_CREATED)
def create_transaction(
    transaction_in: TransactionCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Create a new transaction
    """
    transaction = Transaction(
        **transaction_in.dict(),
        user_id=current_user.id,
    )
    db.add(transaction)
    db.commit()
    db.refresh(transaction)
    
    return transaction

@router.get("", response_model=List[TransactionResponse])
def get_transactions(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 100,
):
    """
    Get all transactions for a user
    """
    transactions = (
        db.query(Transaction)
        .filter(Transaction.user_id == current_user.id)
        .order_by(Transaction.date.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )
    
    return transactions

@router.get("/summary", response_model=TransactionSummary)
def get_transaction_summary(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Get transaction summary for a user
    """
    # Get all transactions for the user
    transactions = (
        db.query(Transaction)
        .filter(Transaction.user_id == current_user.id)
        .all()
    )
    
    # Calculate total income and expense
    total_income = sum(t.amount for t in transactions if t.type == "income")
    total_expense = sum(t.amount for t in transactions if t.type == "expense")
    net_balance = total_income - total_expense
    
    # Calculate category breakdown for expenses
    expense_transactions = [t for t in transactions if t.type == "expense"]
    category_totals = {}
    for t in expense_transactions:
        if t.category not in category_totals:
            category_totals[t.category] = 0
        category_totals[t.category] += t.amount
    
    # Calculate percentages
    categories = []
    for category, amount in category_totals.items():
        percentage = (amount / total_expense * 100) if total_expense > 0 else 0
        categories.append({
            "name": category,
            "amount": amount,
            "percentage": round(percentage, 2),
        })
    
    # Sort by amount
    categories.sort(key=lambda x: x["amount"], reverse=True)
    
    return {
        "total_income": total_income,
        "total_expense": total_expense,
        "net_balance": net_balance,
        "categories": categories,
    }

@router.get("/{transaction_id}", response_model=TransactionResponse)
def get_transaction(
    transaction_id: UUID,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Get a transaction by ID
    """
    transaction = (
        db.query(Transaction)
        .filter(Transaction.id == transaction_id, Transaction.user_id == current_user.id)
        .first()
    )
    
    if not transaction:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Transaction not found",
        )
    
    return transaction

@router.put("/{transaction_id}", response_model=TransactionResponse)
def update_transaction(
    transaction_id: UUID,
    transaction_in: TransactionUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Update a transaction
    """
    transaction = (
        db.query(Transaction)
        .filter(Transaction.id == transaction_id, Transaction.user_id == current_user.id)
        .first()
    )
    
    if not transaction:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Transaction not found",
        )
    
    # Update fields
    for field, value in transaction_in.dict(exclude_unset=True).items():
        setattr(transaction, field, value)
    
    db.commit()
    db.refresh(transaction)
    
    return transaction

@router.delete("/{transaction_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_transaction(
    transaction_id: UUID,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Delete a transaction
    """
    transaction = (
        db.query(Transaction)
        .filter(Transaction.id == transaction_id, Transaction.user_id == current_user.id)
        .first()
    )
    
    if not transaction:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Transaction not found",
        )
    
    db.delete(transaction)
    db.commit()

================
File: app/schemas/transaction.py
================
from typing import Optional, List
from uuid import UUID
from pydantic import BaseModel, validator, confloat
from datetime import date, datetime

from app.models.transaction import TransactionType

# Shared properties
class TransactionBase(BaseModel):
    description: str
    amount: confloat(gt=0)  # positive float
    date: date
    type: TransactionType
    category: str
    notes: Optional[str] = None

# Properties to receive via API on creation
class TransactionCreate(TransactionBase):
    pass

# Properties to receive via API on update
class TransactionUpdate(BaseModel):
    description: Optional[str] = None
    amount: Optional[confloat(gt=0)] = None
    date: Optional[date] = None
    type: Optional[TransactionType] = None
    category: Optional[str] = None
    notes: Optional[str] = None

# Properties to return to client
class TransactionResponse(TransactionBase):
    id: UUID
    user_id: UUID
    created_at: datetime
    
    class Config:
        orm_mode = True

# Properties properties stored in DB
class TransactionInDB(TransactionResponse):
    updated_at: datetime

# Transaction summary
class TransactionSummary(BaseModel):
    total_income: float
    total_expense: float
    net_balance: float
    categories: List[dict]
    
    class Config:
        schema_extra = {
            "example": {
                "total_income": 5000.0,
                "total_expense": 3000.0,
                "net_balance": 2000.0,
                "categories": [
                    {"name": "food", "amount": 1000.0, "percentage": 33.33},
                    {"name": "transport", "amount": 500.0, "percentage": 16.67},
                    {"name": "utilities", "amount": 1500.0, "percentage": 50.0},
                ]
            }
        }

# Transaction analytics
class TransactionAnalytics(BaseModel):
    monthly_summary: List[dict]
    category_breakdown: List[dict]
    income_vs_expense: dict
    
    class Config:
        schema_extra = {
            "example": {
                "monthly_summary": [
                    {"month": "Jan 2023", "income": 5000.0, "expense": 3000.0, "net": 2000.0},
                    {"month": "Feb 2023", "income": 5200.0, "expense": 3100.0, "net": 2100.0},
                ],
                "category_breakdown": [
                    {"name": "food", "amount": 1000.0, "percentage": 33.33},
                    {"name": "transport", "amount": 500.0, "percentage": 16.67},
                    {"name": "utilities", "amount": 1500.0, "percentage": 50.0},
                ],
                "income_vs_expense": {
                    "income": 10200.0,
                    "expense": 6100.0,
                    "net": 4100.0
                }
            }
        }

================
File: app/schemas/user.py
================
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, EmailStr, validator
from datetime import datetime

# Shared properties
class UserBase(BaseModel):
    email: EmailStr
    name: str

# Properties to receive via API on creation
class UserCreate(UserBase):
    password: str
    
    @validator('password')
    def password_min_length(cls, v):
        if len(v) < 6:
            raise ValueError('Password must be at least 6 characters')
        return v

# Properties to receive via API on update
class UserUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[EmailStr] = None
    password: Optional[str] = None

# Properties to return to client
class UserResponse(UserBase):
    id: UUID
    created_at: datetime
    
    class Config:
        orm_mode = True

# Properties properties stored in DB
class UserInDB(UserResponse):
    password: str
    updated_at: datetime

# Token schema
class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"
    user: UserResponse

# Login schema
class UserLogin(BaseModel):
    email: EmailStr
    password: str

================
File: app/test/auth-test.py
================
import requests
import json
import sys

def test_auth(base_url="http://localhost:8000"):
    """
    Test authentication functionality by:
    1. Creating a test user
    2. Logging in with the test user
    3. Fetching user info with the token
    """
    
    # Define test user data
    test_user = {
        "name": "admin",
        "email": "admin@test.com",
        "password": "password"
    }
    
    # Step 1: Create a test user (signup)
    print("=== Testing User Signup ===")
    try:
        signup_response = requests.post(
            f"{base_url}/api/auth/signup",
            json=test_user
        )
        
        if signup_response.status_code == 201:
            print("✅ User created successfully")
        elif signup_response.status_code == 400 and "Email already registered" in signup_response.text:
            print("ℹ️ User already exists, continuing with login test")
        else:
            print(f"❌ Failed to create user: {signup_response.status_code}")
            print(signup_response.text)
            if signup_response.status_code != 400:  # Only exit if not a duplicate email error
                sys.exit(1)
            
    except Exception as e:
        print(f"❌ Error during signup: {str(e)}")
        sys.exit(1)
    
    # Step 2: Login with test user
    print("\n=== Testing User Login ===")
    try:
        login_data = {
            "email": test_user["email"],
            "password": test_user["password"]
        }
        
        login_response = requests.post(
            f"{base_url}/api/auth/login",
            json=login_data
        )
        
        if login_response.status_code == 200:
            print("✅ Login successful")
            login_json = login_response.json()
            token = login_json.get("access_token")
            user_info = login_json.get("user")
            print(f"Token received: {token[:15]}...")
            print(f"User info: {json.dumps(user_info, indent=2)}")
        else:
            print(f"❌ Login failed: {login_response.status_code}")
            print(login_response.text)
            sys.exit(1)
            
    except Exception as e:
        print(f"❌ Error during login: {str(e)}")
        sys.exit(1)
    
    # Step 3: Get current user with token
    print("\n=== Testing Token Authentication ===")
    try:
        me_response = requests.get(
            f"{base_url}/api/auth/me",
            headers={"Authorization": f"Bearer {token}"}
        )
        
        if me_response.status_code == 200:
            print("✅ Token authentication successful")
            print(f"User data: {json.dumps(me_response.json(), indent=2)}")
        else:
            print(f"❌ Token authentication failed: {me_response.status_code}")
            print(me_response.text)
            
    except Exception as e:
        print(f"❌ Error during token authentication: {str(e)}")
    
    print("\n=== Authentication Test Complete ===")
    print("You can use these credentials to login:")
    print(f"Email: {test_user['email']}")
    print(f"Password: {test_user['password']}")

if __name__ == "__main__":
    # You can provide a custom base URL as a command line argument
    base_url = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:8000"
    test_auth(base_url)

================
File: app/utils/environment.py
================
import os
from enum import Enum
from pathlib import Path

class Environment(str, Enum):
    DEVELOPMENT = "development"
    TESTING = "testing"
    PRODUCTION = "production"

def get_env() -> Environment:
    """Get current environment"""
    env = os.getenv("ENV", "development")
    if env == "production":
        return Environment.PRODUCTION
    elif env == "testing":
        return Environment.TESTING
    return Environment.DEVELOPMENT

def is_development() -> bool:
    """Check if environment is development"""
    return get_env() == Environment.DEVELOPMENT

def is_production() -> bool:
    """Check if environment is production"""
    return get_env() == Environment.PRODUCTION

def is_testing() -> bool:
    """Check if environment is testing"""
    return get_env() == Environment.TESTING

def get_project_root() -> Path:
    """Returns project root folder."""
    return Path(__file__).parent.parent.parent

def load_env_file():
    """
    Load environment variables from the .env file.
    This function can be called at application startup.
    """
    from dotenv import load_dotenv
    
    env_file = get_project_root() / ".env"
    if env_file.exists():
        load_dotenv(env_file)
        print(f"Loaded environment variables from {env_file}")
    else:
        print("Warning: .env file not found")

================
File: app/main.py
================
from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session

from app.core.config import settings
from app.core.database import engine, SessionLocal, Base
from app.routes import auth, transactions, analytics
from app.utils.environment import load_env_file, is_development

# Load environment variables from .env file
load_env_file()

# Create database tables if in development mode
if is_development():
    Base.metadata.create_all(bind=engine)

app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.PROJECT_VERSION,
    description=settings.PROJECT_DESCRIPTION,
    docs_url="/api/docs",
    redoc_url="/api/redoc",
    openapi_url="/api/openapi.json",
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Get database session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Include routers
app.include_router(auth.router, prefix="/api/auth", tags=["Authentication"])
app.include_router(transactions.router, prefix="/api/transactions", tags=["Transactions"])
app.include_router(analytics.router, prefix="/api/analytics", tags=["Analytics"])

@app.get("/api/health", tags=["Health"])
def health_check():
    """
    Health check endpoint
    """
    return {"status": "ok", "version": settings.PROJECT_VERSION, "environment": settings.ENV}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=is_development())

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Virtual environments
venv/
env/
.venv/
.python-version

# macOS system files
.DS_Store

# VSCode and JetBrains IDE settings
.vscode/
.idea/
*.swp
*.swo

# Environment variables
.env
*.env

# Logs and debugging
logs/
*.log
nohup.out

# Compiled Python files
*.pyc
*.pyo
*.pyd

# MyPy type checker
.mypy_cache/
.dmypy.json
dmypy.json

# Pytest cache
.pytest_cache/

# Coverage reports
htmlcov/
.coverage
.coverage.*
*.cover
.cache
nosetests.xml
coverage.xml
*.lcov

# Jupyter notebooks checkpoints
.ipynb_checkpoints

# SQLite database files
*.sqlite3
*.db
*.sqlite
*.db-journal

# Migration files (if using Alembic or Django)
migrations/
alembic/

# Generated API documentation
docs/_build/

# Docker files
docker-compose.override.yml
.dockerignore
*.tar
__pycache__/
*.py[cod]

# AWS, Google Cloud, and Azure credentials
.aws/
.gcloud/
azure/

# FastAPI specific
instance/
staticfiles/
media/

# Pipenv and poetry
Pipfile
Pipfile.lock
poetry.lock

# Local `.dev` files
*.local

# System-wide Python cache
pip-log.txt
pip-delete-this-directory.txt

# Local storage files
storage/
uploads/
tmp/
temp/

# Node.js related (if used for frontend in the same repo)
node_modules/

# Terraform
.terraform/
terraform.tfstate
terraform.tfstate.backup

================
File: Dockerfile
================
FROM python:3.11-slim

WORKDIR /app

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# Install system dependencies
RUN apt-get update \
  && apt-get -y install netcat-traditional gcc \
  && apt-get clean

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . .

# Command to run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

================
File: requirements.txt
================
# FastAPI
fastapi==0.103.1
uvicorn==0.23.2
pydantic
email-validator==2.0.0

# Database
sqlalchemy==2.0.20
psycopg2-binary==2.9.7
alembic==1.12.0

# Security
python-jose==3.3.0
passlib==1.7.4
python-multipart==0.0.6
bcrypt==4.0.1

# CORS
starlette==0.27.0

# Testing
pytest==7.4.1
httpx==0.24.1

# Development
black==23.7.0
isort==5.12.0
